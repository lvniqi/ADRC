小白理解ADRC控制器
==========
整篇文章仅包含毫无意义的公式，有意义的公式都在书里，小白请放心食用:stuck_out_tongue_winking_eye:

## 简介
### 传统PID
传统上，对于模型不确定的系统我们(或者仅仅是我？)都喜欢用PID控制。
即使在模型清楚的情况下，有时我们也很难获得模型的部分参数，所以继续沿用PID控制器。

一般我们看到的的pid控制是长这样的：

<div align=center>
<img src="https://imgsa.baidu.com/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60/sign=0c235bc3740e0cf3b4fa46a96b2f997a/5243fbf2b21193132c0f096163380cd790238d97.jpg" width="400"  />
</div>

如果把这样的pid控制器写成传递函数，就是

![](http://latex.codecogs.com/gif.latex?G(s)=P+I\\frac{1}{s}+Ds)

Z变换的话是变成

![](http://latex.codecogs.com/gif.latex?G(z)=P+I\cdot{T_s}\\frac{1}{z-1}+D\\frac{z-1}{z\cdot{T_s}})

嗯~看起来挺不错的，那么问题在哪儿呢？

#### 微分不可用
在实际场景中，上面的pid控制上存在一个巨大的问题，即D分量一般并不可用。因为对象输出c(t)存在噪声，简单做微分会导致噪声引入系统导致系统不稳定。

#### 超调的产生


任何一个控制器，其最终目的都是希望输出c(t)尽可能快地跟踪输入r(t)。在大多数情况下，我们希望这个跟踪没有超调和振荡。然而这个愿望可能实现吗？

我们观察一个二阶系统：

![](http://latex.codecogs.com/gif.latex?G(s)=\\frac{a_1}{s^2+a_2s+a_1})

当且仅当![](http://latex.codecogs.com/gif.latex?{a_2}=2\\sqrt{a_1})时，系统是临界阻尼状态，此时系统既没有超调振荡，跟踪速度也是较快的。
而我们制作的控制器也是希望能修改原有的传递函数，使得其能实现类似于临界阻尼这样的状态。对于大多数二阶系统而言，PID控制就能做到。

但如果a1和a2在系统运行中有些许变化怎么办？
额，这时候简单的PID就要出事了。（至于为什么，额，我数学不好，谁有兴趣谁推导:astonished:）









## 参考文献
[1]韩京清. 自抗扰控制技术: 估计补偿不确定因素的控制技术[M]. 国防工业出版社, 2008.