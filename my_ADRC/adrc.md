小白理解ADRC控制器
==========
整篇文章仅包含毫无意义的公式，有意义的公式都在书里，小白请放心食用:stuck_out_tongue_winking_eye:

## 简介
### 传统PID
传统上，对于模型不确定的系统我们(或者仅仅是我？)都喜欢用PID控制。
即使在模型清楚的情况下，有时我们也很难获得模型的部分参数，所以继续沿用PID控制器。

一般我们看到的的pid控制是长这样的：

<div align=center>
<img src="https://imgsa.baidu.com/baike/c0%3Dbaike180%2C5%2C5%2C180%2C60/sign=0c235bc3740e0cf3b4fa46a96b2f997a/5243fbf2b21193132c0f096163380cd790238d97.jpg" width="400"  />
</div>

如果把这样的pid控制器写成传递函数，就是

![](http://latex.codecogs.com/gif.latex?G(s)=P+I\\frac{1}{s}+Ds)

Z变换的话是变成

![](http://latex.codecogs.com/gif.latex?G(z)=P+I\cdot{T_s}\\frac{1}{z-1}+D\\frac{z-1}{z\cdot{T_s}})

嗯~看起来挺不错的，那么问题在哪儿呢？

#### 微分不可用
在实际场景中，上面的pid控制上存在一个巨大的问题，即D分量一般并不可用。因为对象输出c(t)存在噪声，简单做微分会导致噪声引入系统导致系统不稳定。

#### 超调&&过渡过程


任何一个控制器，其最终目的都是希望输出c(t)尽可能快地跟踪输入r(t)。在大多数情况下，我们希望这个跟踪没有超调和振荡。然而这个愿望可能实现吗？

我们观察一个二阶系统：

![](http://latex.codecogs.com/gif.latex?G(s)=\\frac{a_1}{s^2+a_2s+a_1})

当且仅当![](http://latex.codecogs.com/gif.latex?{a_2}=2\\sqrt{a_1})时，系统是临界阻尼状态，此时系统既没有超调振荡，跟踪速度也是较快的。
而我们制作的控制器也是希望能修改原有的传递函数，使得其能实现类似于临界阻尼这样的状态。对于大多数二阶系统而言，PID控制就能做到。

但如果a1和a2在系统运行中有些许变化怎么办？
额，这时候简单的PID就要出事了。（至于为什么，额，我数学不好，谁有兴趣谁推导:joy:）

其实在我们输入r(t)的时候，输入的期望是不连续的(比如阶跃)。在调节时间ts内，我们实际上在强控制器所难，因为它的输出本来就不可能到达我们期望的输入。如果不作理论推导(又不做推导，我这样是要被打的:dizzy_face:)，单凭直觉，我们很容易想象，一个含有惯性过程的系统，在e(t)较大的情况下很可能出现超调的情况。如果我们换个思路，为控制器设计一个合理的过渡过程，是不是能减轻下这个控制器的负担，初始u(t)不会过大，超调也会减少一部分。

#### 积分反馈的问题
PID中的I项是用于抑制常值扰动，减少稳态误差的。然而添加I项可能导致系统动态特性变差，又有积分饱和的问题。这项这么扔着真的好么。

#### PID控制器本身
PID是将比例、积分、微分做线性加权和作为调节器输出扔给被控对象的(类似单个无偏置神经元？:point_left:)。这么做是不是合适？用非线性组合是不是更好？

<img src="https://yuml.me/diagram/scruffy/class/[输入]->[过渡过程{bg:green}],[过渡过程]v1->[sum_1],[过渡过程]v2->[sum_2],[扩张状态观测器{bg:orange}]z1_n->[sum_1],[扩张状态观测器]z2_n->[sum_2],[sum_1]e1->[非线性组合],[sum_2]e2->[非线性组合{bg:red}],[非线性组合]u0->[sum_3],[sum_3]u->[对象],[对象]->[输出2]，[输出2]y->[扩张状态观测器],[sum_3]->[b0],[b0]->[扩张状态观测器],[扩张状态观测器]z3_n->[1/b0],[1/b0]->[sum_3]" >




## 参考文献
[1]韩京清. 自抗扰控制技术: 估计补偿不确定因素的控制技术[M]. 国防工业出版社, 2008.